"""Module for compiling codegen-output, and wrap it for use in python.

What?

This module provides a common interface for different external backends, such
as f2py, fwrap, Cython, SWIG(?) etc.  The goal is to provide access to compiled
binaries of acceptable performance with a one-button user interface, i.e.

    >>> from sympy.abc import x,y
    >>> from sympy.utilities.autowrap import autowrap
    >>> expr = ((x - y)**(25)).expand()
    >>> binary_callable = autowrap(expr)
    >>> binary_callable(1, 2)           #doctest: +SKIP
    -1.0

The callable returned from autowrap() is a binary python function, not a
Sympy object.  If it is desired to use the compiled function in symbolic
expressions, it is better to use binary_function() which returns a Sympy
Function object.  The binary callable is attached as the _imp_ attribute and
invoked when a numerical evaluation is requested with evalf(), or with
lambdify().

    >>> from sympy.utilities.autowrap import binary_function
    >>> f = binary_function('f', expr)
    >>> 2*f(x, y) + y
    y + 2*f(x, y)
    >>> (2*f(x, y) + y).evalf(2, subs={x: 1, y:2})    #doctest: +SKIP
    0.0

Why?

The idea is that a SymPy user will primarily be interested in working with
mathematical expressions, and should not have to learn details about wrapping
tools in order to evaluate expressions numerically, even if they are
computationally expensive.

When is this useful?

    1) For computations on large arrays, Python iterations may be too slow, and
    depending on the mathematical expression, it may be difficult to exploit
    the advanced index operations provided by NumPy.

    2) For *really* long expressions that will be called repeatedly, the
    compiled binary should be significantly faster than SymPy's .evalf()

    3) If you are generating code with the codegen utility in order to use it
    in another project, the automatic python wrappers let you test the binaries
    immediately from within SymPy.

When is this module NOT the best approach?

    1) If you are really concerned about speed or memory optimizations, you
    will probably get better results by working directly with the wrapper tools
    and the low level code.  However, the files generated by this utility may
    provide a useful starting point and reference code. Temporary files will be
    left intact if you supply the keyword filepath="path/to/files/".

    2) If the array computation can be handled easily by numpy, and you don't
    need the binaries for another project.

"""
import sys
import os
import shutil
import tempfile
import subprocess

from sympy.utilities.codegen import codegen, get_code_generator, Routine
from sympy.utilities.lambdify import implemented_function

class CodeWrapError(Exception): pass

class CodeWrapper:
    _filename = "codewrapper"
    _module_basename = "autowrapped"
    _module_counter = 0

    @property
    def module_name(self):
        return "%s_%s" % (self._module_basename, CodeWrapper._module_counter)

    def __init__(self, generator, filepath=None):
        """
        generator -- the code generator to use
        """
        self.generator = generator
        self.filepath = filepath

    @property
    def include_header(self):
        return bool(self.filepath)

    @property
    def include_empty(self):
        return bool(self.filepath)

    def _generate_code(self, routine):
        self.generator.write([routine], self._filename, True, self.include_header,
                self.include_empty)

    def wrap_code(self, routine):

        workdir = self.filepath or tempfile.mkdtemp("_sympy_compile")
        if not os.access(workdir, os.F_OK):
            os.mkdir(workdir)
        oldwork = os.getcwd()
        os.chdir(workdir)
        try:
            sys.path.append(workdir)
            self._generate_code(routine)
            self._prepare_files(routine)
            self._process_files(routine)
            mod = __import__(self.module_name)
        finally:
            sys.path.pop()
            CodeWrapper._module_counter +=1
            os.chdir(oldwork)
            if not self.filepath:
                shutil.rmtree(workdir)

        return self._get_wrapped_function(mod)

class F2PyCodeWrapper(CodeWrapper):

    def _process_files(self, routine):
        filename = self._filename + '.' + self.generator.dump_f95.extension
        command = ["f2py", "-m", self.module_name, "-c" , filename]
        null = open(os.devnull, 'w')
        retcode = subprocess.call(command, stdout=null)
        if retcode:
            raise CodeWrapError

    def _prepare_files(self, routine):
        pass

    @classmethod
    def _get_wrapped_function(cls, mod):
        return mod.autofunc

def _get_code_wrapper_class(backend):
    wrappers = { 'F2PY': F2PyCodeWrapper }
    return wrappers[backend.upper()]


def autowrap(expr, language='F95', backend='f2py', tempdir=None):
    """Generates python callable binaries based on the math expression.

    expr  --  the SymPy expression that should be wrapped as a binary routine

    Otional arguments:
    language  --  the programming language to use, currently C or F95
    backend  --  the wrapper backend to use, currently f2py or Cython
    tempdir  --  path to directory for temporary files.  If this argument is
                 supplied, the generated code and the wrapper input files are
                 left intact in the specified path.

    >>> from sympy.abc import x, y, z
    >>> from sympy.utilities.autowrap import autowrap
    >>> expr = ((x - y + z)**(13)).expand()
    >>> binary_func = autowrap(expr)
    >>> binary_func(1, 4, 2)
    -1.0

    """

    code_generator = get_code_generator(language, "autowrap")
    CodeWrapperClass = _get_code_wrapper_class(backend)
    code_wrapper = CodeWrapperClass(code_generator, tempdir)
    routine  = Routine('autofunc',expr)
    return code_wrapper.wrap_code(routine)

def binary_function(symfunc, expr, **kwargs):
    """Returns a sympy function with expr as binary implementation

    This is a convenience function that relies on autowrap() and implemented_function()

    >>> from sympy.abc import x, y, z
    >>> from sympy.utilities.autowrap import binary_function
    >>> expr = ((x - y)**(25)).expand()
    >>> f = binary_function('f', expr)
    >>> type(f)
    <class 'sympy.core.function.FunctionClass'>
    >>> 2*f(x, y)
    2*f(x, y)
    >>> f(x, y).evalf(2, subs={x: 1, y: 2})
    -1.0
    """
    binary = autowrap(expr, **kwargs)
    return implemented_function(symfunc, binary)
